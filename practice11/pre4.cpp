#include <iostream>
#include <string>
using namespace std;
int main()
{
    string line1, line2, line3, field;
    int amountX=0, amountO=0, amountDot=0;
    bool winX = false, winO = false;
    cin >> line1 >> line2 >> line3;
    field = line1 + line2 + line3;

    if (line1.length() != 3 || line2.length() != 3 || line3.length() != 3)
    {
        cout << "Incorrect 1\n";
        return 1;
    }
    for (int i = 0; i < field.length(); i++)
    {
        if (field[i] == 'X') amountX++;
        if (field[i] == 'O') amountO++;
        if (field[i] == '.') amountDot++;
    }
    if (amountX > amountO+1 || amountO > amountX)
    {
        cout << "Incorrect 2\n";
        return 1;
    }
    if (field[0] == 'X' && field[1] == 'X' && field[2] == 'X' || field[3] == 'X' && field[4] == 'X' && field[5] == 'X' || field[6] == 'X' && field[7] == 'X' && field[8] == 'X'
     || field[0] == 'X' && field[3] == 'X' && field[6] == 'X' || field[1] == 'X' && field[4] == 'X' && field[7] == 'X' || field[2] == 'X' && field[5] == 'X' && field[8] == 'X'
     || field[0] == 'X' && field[4] == 'X' && field[8] == 'X' || field[2] == 'X' && field[4] == 'X' && field[6] == 'X')
    {
        winX = true;
    }
    if (field[0] == 'O' && field[1] == 'O' && field[2] == 'O' || field[3] == 'O' && field[4] == 'O' && field[5] == 'O' || field[6] == 'O' && field[7] == 'O' && field[8] == 'O'
     || field[0] == 'O' && field[3] == 'O' && field[6] == 'O' || field[1] == 'O' && field[4] == 'O' && field[7] == 'O' || field[2] == 'O' && field[5] == 'O' && field[8] == 'O'
     || field[0] == 'O' && field[4] == 'O' && field[8] == 'O' || field[2] == 'O' && field[4] == 'O' && field[6] == 'O')
    {
        winO = true;
    }
    if (winX && winO)
    {
        cout << "Incorrect 3\n";
        return 1;
    }

    if (winX && amountO != amountX - 1)
    {
        cout << "Incorrect 4\n";
        return 1;
    }
    else if (winO && amountX != amountO)
    {
        cout << "Incorrect 5\n";
        return 1;
    }
    else if (!winO && !winX)
    {
        cout << "Nobody\n";
        return 0;
    } else if (winX) cout << "Petya won\n";
    else if (winO) cout << "Vanya won\n";
}
/*
Задание 4. Оценка результатов игры в крестики-нолики
Что нужно сделать
Петя и Вася играли в крестики-нолики и не стёрли результаты своей игры. Теперь перед вами табличка 3 × 3, которая осталась после их поединка. Вы хотите понять, выиграл ли
кто-то из них или они не доиграли.

На вход программе даётся три строки, кодирующие верхнюю, среднюю и нижнюю строчки игрового поля. Крестик обозначается символом X (английская заглавная буква X),
нолик — символом O (заглавная английская буква O), пустая клетка — точкой.

Если ввод некорректен, то есть такая таблица не могла получиться в ходе настоящей игры, то надо написать в ответ слово Incorrect.

Если таблица корректна и выиграли крестики, то нужно вывести в ответ слова Petya won, если нолики — Vanya won, иначе (то есть они не доиграли или сыграли вничью) надо написать Nobody.

Примеры

X.. 
OXO 
OOO 
Ответ: Incorrect (потому что ноликов в конце игры не может быть больше, чем крестиков).

X.. 
.X. 
OO. 
Ответ: Nobody (потому что они не доиграли).

XXO 
OOX 
XOX 
Ответ: Nobody (потому что это ничья).

XO. 
XO. 
X.O 
Ответ: Incorrect (крестики уже победили, и ноликов не может быть столько же).

OX. 
XOX 
X.O 
Ответ: Incorrect (потому что нолики выиграли за три хода, и на поле за это время не могло успеть появиться четыре крестика).

..X 
OX. 
X.O 
Ответ: Petya won.

0.. 
... 
... 
Ответ: Incorrect (потому что допускаются только символы X, O и точка, а цифра 0 не является допустимым символом).

Рекомендации
Чтобы обращаться к элементам игрового поля, стоит написать отдельную функцию получения элемента поля по его координатам (x, y). В таком случае часть алгоритмов поиска
победителя можно обобщить.
Функции проверки поля на корректность можно отделить от функций и алгоритмов проверки победителя.
При достаточной модульности функций некоторые операции можно реализовать через уже существующие процедуры. К примеру, если уже есть проверка победителя в строке и имеется
функция получения колонки по индексу, то функцию поиска победителя в колонке можно реализовать через обе процедуры.
Проход по диагонали поля можно осуществить в цикле, используя счётчик цикла в качестве обоих координат элемента. Для второй диагонали нужно обратить одну из координат
(2 − x или 2 − y).
Общие условия некорректности поля таковы:
выявлено несколько победителей одновременно;
нолики победили, а крестиков больше, чем ноликов;
крестики победили, а ноликов столько же или больше;
нолики и крестики победили несколько раз;
на поле есть невалидные символы.
Для упрощения лучше создать отдельные функции для проверки победителя в строке или столбце, которые на вход принимают строку, а на выходе выдают символ победителя. То есть
‘X’, ‘O’ или ‘.’
*/